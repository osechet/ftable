/*
 * FontChooser.java
 *
 * Copyright (C) 2009 Olivier Sechet
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, see <http://www.gnu.org/licenses/>.
 */
package net.druppi.swing;

import java.awt.Color;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.font.TextAttribute;
import java.io.Serializable;
import java.util.Map;

import javax.swing.AbstractListModel;
import javax.swing.BorderFactory;
import javax.swing.DefaultComboBoxModel;
import javax.swing.GroupLayout;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JColorChooser;
import javax.swing.JComboBox;
import javax.swing.JDialog;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextField;
import javax.swing.ListModel;
import javax.swing.ListSelectionModel;
import javax.swing.ScrollPaneConstants;
import javax.swing.SwingConstants;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;
import javax.swing.GroupLayout.Alignment;
import javax.swing.LayoutStyle.ComponentPlacement;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import net.druppi.swing.font.FontListModel;
import net.druppi.util.ResourceManager;


/**
 * The FontChooser is a panel that can be used to choose a Font. The user can select the
 * font family, the font style (regular, bold, italic), the size, the underline type or if
 * the font is stroked. <br>
 * The FontChooser displays all the fonts available on the system.
 *
 * @author Olivier Sechet
 * @version 1.0 - Apr 9, 2009
 */
@SuppressWarnings("serial")
public class FontChooser extends javax.swing.JPanel {

    /** The selected font. */
    private Font font;

    /** The foreground color. */
    private Color foreground;

    /** The panel's color chooser. */
    private JColorChooser colorChooser;

    /** The colorChooser tracker. It is used to know which button has been selected. */
    private ColorTracker ok;

    /** The colorChooser dialog. */
    private JDialog colorDialog;

    /**
     * Creates new form FontChooser.
     */
    public FontChooser() {
        initComponents();

        foreground = colorPickLabel.getBackground();
        setSelectedFont(new Font("Arial", Font.PLAIN, 12)); //$NON-NLS-1$
    }

    /**
     * Selects the specified font.
     *
     * @param font the font to select.
     */
    public void setSelectedFont(final Font font) {
        Font oldFont = this.font;
        this.font = font;

        if (!font.equals(oldFont)) {
            fontChanged();
        }
    }

    /**
     * Returns the chosen font.
     *
     * @return the font.
     */
    public Font getSelectedFont() {
        return font;
    }

    /**
     * Sets the text color.
     *
     * @param color the new color.
     */
    public void setTextColor(Color color) {
        this.foreground = color;
        colorPickLabel.setBackground(foreground);

        fontChanged();
    }

    /**
     * Returns the text color.
     *
     * @return the text color.
     */
    public Color getTextColor() {
        return foreground;
    }

    /**
     * Updates the GUI according to the new font.
     */
    private void fontChanged() {
        fontList.setSelectedValue(font.getName(), true);
        fontStyleList.setSelectedIndex(font.getStyle());
        sizeList.setSelectedValue(Integer.toString(font.getSize()), true);

        previewLabel.setFont(font);
        previewLabel.setForeground(foreground);
    }

    /**
     * This method is called from within the constructor to initialize the form. WARNING:
     * Do NOT modify this code. The content of this method is always regenerated by the
     * Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        fontLabel = new JLabel();
        fontTextField = new JTextField();
        fontScrollPane = new JScrollPane();
        fontList = new JList();
        fontStyleTextField = new JTextField();
        fontStyleLabel = new JLabel();
        fontStyleScrollPane = new JScrollPane();
        fontStyleList = new JList();
        sizeTextField = new JTextField();
        sizeLabel = new JLabel();
        sizeScrollPane = new JScrollPane();
        sizeList = new JList();
        underlineLabel = new JLabel();
        underlineComboBox = new JComboBox();
        colorLabel = new JLabel();
        effectsPanel = new JPanel();
        strikethroughCheckBox = new JCheckBox();
        superscriptCheckBox = new JCheckBox();
        subscriptCheckBox = new JCheckBox();
        previewPanel = new JPanel();
        previewLabel = new JLabel();
        colorPickLabel = new JLabel();
        selectColorButton = new JButton();

        setName("Form"); // NOI18N

        fontLabel.setDisplayedMnemonic(ResourceManager.getResourceMap(getClass()).getString("FontChooser.fontLabel.mnemonic").charAt(0));
        fontLabel.setLabelFor(fontTextField);
        fontLabel.setText(ResourceManager.getResourceMap(getClass()).getString("FontChooser.fontLabel.text")); // NOI18N
        fontLabel.setName("fontLabel"); // NOI18N

        fontTextField.setName("fontTextField"); // NOI18N
        fontTextField.getDocument().addDocumentListener(new DocumentListener() {
            public void changedUpdate(final DocumentEvent evt) {
                fontTextFieldChanged();
            }
            public void insertUpdate(final DocumentEvent evt) {
                fontTextFieldChanged();
            }
            public void removeUpdate(final DocumentEvent evt) {
                fontTextFieldChanged();
            }
        });

        fontScrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        fontScrollPane.setName("fontScrollPane"); // NOI18N

        fontList.setModel(new FontListModel());
        fontList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        fontList.setName("fontList"); // NOI18N
        fontList.addListSelectionListener(new ListSelectionListener() {
            public void valueChanged(ListSelectionEvent evt) {
                fontListValueChanged(evt);
            }
        });
        fontScrollPane.setViewportView(fontList);

        fontStyleTextField.setName("fontStyleTextField"); // NOI18N
        fontStyleTextField.getDocument().addDocumentListener(new DocumentListener() {
            public void changedUpdate(final DocumentEvent evt) {
                fontStyleTextFieldChanged();
            }
            public void insertUpdate(final DocumentEvent evt) {
                fontStyleTextFieldChanged();
            }
            public void removeUpdate(final DocumentEvent evt) {
                fontStyleTextFieldChanged();
            }
        });

        fontStyleLabel.setDisplayedMnemonic(ResourceManager.getResourceMap(getClass()).getString("FontChooser.fontStyleLabel.mnemonic").charAt(0));
        fontStyleLabel.setLabelFor(fontStyleTextField);
        fontStyleLabel.setText(ResourceManager.getResourceMap(getClass()).getString("FontChooser.fontStyleLabel.text")); // NOI18N
        fontStyleLabel.setName("fontStyleLabel"); // NOI18N

        fontStyleScrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        fontStyleScrollPane.setName("fontStyleScrollPane"); // NOI18N

        fontStyleList.setModel(new AbstractListModel() {
            String[] strings = { "Regular", "Bold", "Italic", "Bold Italic" };
            public int getSize() { return strings.length; }
            public Object getElementAt(int i) { return strings[i]; }
        });
        fontStyleList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        fontStyleList.setName("fontStyleList"); // NOI18N
        fontStyleList.addListSelectionListener(new ListSelectionListener() {
            public void valueChanged(ListSelectionEvent evt) {
                fontStyleListValueChanged(evt);
            }
        });
        fontStyleScrollPane.setViewportView(fontStyleList);

        sizeTextField.setName("sizeTextField"); // NOI18N
        sizeTextField.getDocument().addDocumentListener(new DocumentListener() {
            public void changedUpdate(final DocumentEvent evt) {
                sizeTextFieldChanged();
            }
            public void insertUpdate(final DocumentEvent evt) {
                sizeTextFieldChanged();
            }
            public void removeUpdate(final DocumentEvent evt) {
                sizeTextFieldChanged();
            }
        });

        sizeLabel.setDisplayedMnemonic(ResourceManager.getResourceMap(getClass()).getString("FontChooser.sizeLabel.mnemonic").charAt(0));
        sizeLabel.setLabelFor(sizeTextField);
        sizeLabel.setText(ResourceManager.getResourceMap(getClass()).getString("FontChooser.sizeLabel.text")); // NOI18N
        sizeLabel.setName("sizeLabel"); // NOI18N

        sizeScrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        sizeScrollPane.setName("sizeScrollPane"); // NOI18N

        sizeList.setModel(new AbstractListModel() {
            String[] strings = { "8", "9", "10", "11", "12", "14", "16", "18", "20", "22", "24", "26", "28", "36", "48", "72" };
            public int getSize() { return strings.length; }
            public Object getElementAt(int i) { return strings[i]; }
        });
        sizeList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        sizeList.setName("sizeList"); // NOI18N
        sizeList.addListSelectionListener(new ListSelectionListener() {
            public void valueChanged(ListSelectionEvent evt) {
                sizeListValueChanged(evt);
            }
        });
        sizeScrollPane.setViewportView(sizeList);

        underlineLabel.setDisplayedMnemonic(ResourceManager.getResourceMap(getClass()).getString("FontChooser.underlineLabel.mnemonic").charAt(0));
        underlineLabel.setLabelFor(underlineComboBox);
        underlineLabel.setText(ResourceManager.getResourceMap(getClass()).getString("FontChooser.underlineLabel.text")); // NOI18N
        underlineLabel.setName("underlineLabel"); // NOI18N

        underlineComboBox.setModel(new DefaultComboBoxModel(new String[] { "None", "Single", "Double", "Dotted", "Dashed" }));
        underlineComboBox.setName("underlineComboBox"); // NOI18N
        underlineComboBox.addItemListener(new ItemListener() {
            public void itemStateChanged(ItemEvent evt) {
                underlineComboBoxItemStateChanged(evt);
            }
        });

        colorLabel.setText(ResourceManager.getResourceMap(getClass()).getString("FontChooser.colorLabel.text")); // NOI18N
        colorLabel.setName("colorLabel"); // NOI18N

        effectsPanel.setBorder(BorderFactory.createTitledBorder(ResourceManager.getResourceMap(getClass()).getString("FontChooser.effectsPanel.title"))); // NOI18N
        effectsPanel.setName("effectsPanel"); // NOI18N

        strikethroughCheckBox.setText(ResourceManager.getResourceMap(getClass()).getString("FontChooser.strikethroughCheckBox.text")); // NOI18N
        strikethroughCheckBox.setName("strikethroughCheckBox"); // NOI18N
        strikethroughCheckBox.addItemListener(new ItemListener() {
            public void itemStateChanged(ItemEvent evt) {
                strikethroughCheckBoxItemStateChanged(evt);
            }
        });

        superscriptCheckBox.setText(ResourceManager.getResourceMap(getClass()).getString("FontChooser.superscriptCheckBox.text")); // NOI18N
        superscriptCheckBox.setName("superscriptCheckBox"); // NOI18N
        superscriptCheckBox.addItemListener(new ItemListener() {
            public void itemStateChanged(ItemEvent evt) {
                superscriptCheckBoxItemStateChanged(evt);
            }
        });

        subscriptCheckBox.setText(ResourceManager.getResourceMap(getClass()).getString("FontChooser.subscriptCheckBox.text")); // NOI18N
        subscriptCheckBox.setName("subscriptCheckBox"); // NOI18N
        subscriptCheckBox.addItemListener(new ItemListener() {
            public void itemStateChanged(ItemEvent evt) {
                superscriptCheckBoxItemStateChanged(evt);
            }
        });

        GroupLayout effectsPanelLayout = new GroupLayout(effectsPanel);
        effectsPanel.setLayout(effectsPanelLayout);
        effectsPanelLayout.setHorizontalGroup(
            effectsPanelLayout.createParallelGroup(Alignment.LEADING)
            .addGroup(effectsPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(effectsPanelLayout.createParallelGroup(Alignment.LEADING)
                    .addComponent(strikethroughCheckBox, GroupLayout.DEFAULT_SIZE, 126, Short.MAX_VALUE)
                    .addComponent(superscriptCheckBox, GroupLayout.DEFAULT_SIZE, 126, Short.MAX_VALUE)
                    .addComponent(subscriptCheckBox, GroupLayout.DEFAULT_SIZE, 126, Short.MAX_VALUE))
                .addContainerGap())
        );
        effectsPanelLayout.setVerticalGroup(
            effectsPanelLayout.createParallelGroup(Alignment.LEADING)
            .addGroup(effectsPanelLayout.createSequentialGroup()
                .addComponent(strikethroughCheckBox)
                .addPreferredGap(ComponentPlacement.RELATED)
                .addComponent(superscriptCheckBox)
                .addPreferredGap(ComponentPlacement.RELATED)
                .addComponent(subscriptCheckBox)
                .addContainerGap(GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        previewPanel.setBorder(BorderFactory.createTitledBorder("null"));
        previewPanel.setName("previewPanel"); // NOI18N

        previewLabel.setBackground(new Color(255, 255, 255));
        previewLabel.setHorizontalAlignment(SwingConstants.CENTER);
        previewLabel.setText("AaBbCcYyZz"); // NOI18N
        previewLabel.setBorder(BorderFactory.createLineBorder(new Color(0, 0, 0)));
        previewLabel.setName("previewLabel"); // NOI18N
        previewLabel.setOpaque(true);

        GroupLayout previewPanelLayout = new GroupLayout(previewPanel);
        previewPanel.setLayout(previewPanelLayout);
        previewPanelLayout.setHorizontalGroup(
            previewPanelLayout.createParallelGroup(Alignment.LEADING)
            .addComponent(previewLabel, GroupLayout.DEFAULT_SIZE, 169, Short.MAX_VALUE)
        );
        previewPanelLayout.setVerticalGroup(
            previewPanelLayout.createParallelGroup(Alignment.LEADING)
            .addComponent(previewLabel, GroupLayout.DEFAULT_SIZE, 76, Short.MAX_VALUE)
        );

        colorPickLabel.setBackground(new Color(0, 0, 0));
        colorPickLabel.setBorder(BorderFactory.createLineBorder(new Color(0, 0, 0)));
        colorPickLabel.setName("colorPickLabel"); // NOI18N
        colorPickLabel.setOpaque(true);

        selectColorButton.setText(ResourceManager.getResourceMap(getClass()).getString("FontChooser.selectColorButton.text")); // NOI18N
        selectColorButton.setName("selectColorButton"); // NOI18N
        selectColorButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                selectColorButtonActionPerformed(evt);
            }
        });

        GroupLayout layout = new GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(Alignment.LEADING)
                    .addComponent(effectsPanel, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(underlineLabel, GroupLayout.PREFERRED_SIZE, 150, GroupLayout.PREFERRED_SIZE)
                    .addComponent(underlineComboBox, 0, 150, Short.MAX_VALUE)
                    .addComponent(fontLabel, GroupLayout.PREFERRED_SIZE, 150, GroupLayout.PREFERRED_SIZE)
                    .addComponent(fontTextField, GroupLayout.DEFAULT_SIZE, 150, Short.MAX_VALUE)
                    .addComponent(fontScrollPane, GroupLayout.DEFAULT_SIZE, 150, Short.MAX_VALUE))
                .addGroup(layout.createParallelGroup(Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addPreferredGap(ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(Alignment.LEADING)
                            .addComponent(previewPanel, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(colorLabel, GroupLayout.PREFERRED_SIZE, 100, GroupLayout.PREFERRED_SIZE)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(Alignment.TRAILING)
                                    .addComponent(fontStyleScrollPane, Alignment.LEADING, GroupLayout.DEFAULT_SIZE, 100, Short.MAX_VALUE)
                                    .addComponent(fontStyleTextField, Alignment.LEADING, GroupLayout.DEFAULT_SIZE, 100, Short.MAX_VALUE)
                                    .addComponent(fontStyleLabel, Alignment.LEADING, GroupLayout.PREFERRED_SIZE, 100, GroupLayout.PREFERRED_SIZE))
                                .addPreferredGap(ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(Alignment.LEADING)
                                    .addComponent(sizeTextField, GroupLayout.DEFAULT_SIZE, 75, Short.MAX_VALUE)
                                    .addComponent(sizeLabel, GroupLayout.PREFERRED_SIZE, 75, GroupLayout.PREFERRED_SIZE)
                                    .addComponent(sizeScrollPane, GroupLayout.DEFAULT_SIZE, 75, Short.MAX_VALUE)))))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(16, 16, 16)
                        .addComponent(colorPickLabel, GroupLayout.PREFERRED_SIZE, 16, GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(ComponentPlacement.UNRELATED)
                        .addComponent(selectColorButton)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(Alignment.BASELINE)
                    .addComponent(fontLabel)
                    .addComponent(fontStyleLabel)
                    .addComponent(sizeLabel))
                .addPreferredGap(ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(Alignment.BASELINE)
                    .addComponent(fontTextField, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
                    .addComponent(fontStyleTextField, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
                    .addComponent(sizeTextField, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(Alignment.LEADING)
                    .addComponent(fontScrollPane, GroupLayout.DEFAULT_SIZE, 93, Short.MAX_VALUE)
                    .addComponent(sizeScrollPane, GroupLayout.DEFAULT_SIZE, 93, Short.MAX_VALUE)
                    .addComponent(fontStyleScrollPane, GroupLayout.DEFAULT_SIZE, 93, Short.MAX_VALUE))
                .addPreferredGap(ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(Alignment.BASELINE)
                    .addComponent(underlineLabel)
                    .addComponent(colorLabel))
                .addGap(7, 7, 7)
                .addGroup(layout.createParallelGroup(Alignment.CENTER)
                    .addComponent(colorPickLabel, GroupLayout.PREFERRED_SIZE, 16, GroupLayout.PREFERRED_SIZE)
                    .addComponent(underlineComboBox, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
                    .addComponent(selectColorButton))
                .addPreferredGap(ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(Alignment.LEADING, false)
                    .addComponent(previewPanel, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(effectsPanel, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Called when the selection of the font list changes.
     *
     * @param evt an event.
     */
    private void fontListValueChanged(ListSelectionEvent evt) {// GEN-FIRST:event_fontListValueChanged
        if (!evt.getValueIsAdjusting()) {
            JList list = (JList) evt.getSource();
            int index = list.getSelectedIndex();
            if (index >= 0) {
                final Font newFont = ((FontListModel) list.getModel()).getFont(index);
                fontTextField.setText(newFont.getName());

                Map<TextAttribute, Object> attributes = (Map<TextAttribute, Object>) font.getAttributes();
                attributes.put(TextAttribute.FAMILY, newFont.getFamily());
                font = new Font(attributes);

                fontChanged();
            }
        }
    }// GEN-LAST:event_fontListValueChanged

    /**
     * Called when the content of the font textField changes.
     */
    private void fontTextFieldChanged() {
        String text = fontTextField.getText().toLowerCase();
        ListModel model = fontList.getModel();
        int size = model.getSize();
        for (int i = 0; i < size; i++) {
            final String name = ((String) model.getElementAt(i));
            String lowerCaseName = name.toLowerCase();
            if (lowerCaseName.equals(text)) {
                String oldName = (String) fontList.getSelectedValue();
                if (!name.equals(oldName)) {
                    // The selection has to be "invoked later" to avoid a concurrent modification
                    fontList.setSelectedValue(name, true);
                }
                break;
            } else if (lowerCaseName.startsWith(text)) {
                fontList.ensureIndexIsVisible(i);
                break;
            }
        }
    }

    /**
     * Called when the selection of the style list changes.
     *
     * @param evt an event.
     */
    private void fontStyleListValueChanged(ListSelectionEvent evt) {// GEN-FIRST:event_fontStyleListValueChanged
        if (!evt.getValueIsAdjusting()) {
            JList list = (JList) evt.getSource();
            int index = list.getSelectedIndex();
            if (index >= 0) {
                String newValue = (String) list.getModel().getElementAt(index);
                fontStyleTextField.setText(newValue);

                // The font style values match the indices in the list
                Map<TextAttribute, Object> attributes = (Map<TextAttribute, Object>) font.getAttributes();
                if ((index & Font.BOLD) != 0) {
                    attributes.put(TextAttribute.WEIGHT, TextAttribute.WEIGHT_BOLD);
                } else {
                    attributes.put(TextAttribute.WEIGHT, TextAttribute.WEIGHT_REGULAR);
                }
                if ((index & Font.ITALIC) != 0) {
                    attributes.put(TextAttribute.POSTURE, TextAttribute.POSTURE_OBLIQUE);
                } else {
                    attributes.put(TextAttribute.POSTURE, TextAttribute.POSTURE_REGULAR);
                }
                font = new Font(attributes);

                fontChanged();
            }
        }
    }// GEN-LAST:event_fontStyleListValueChanged

    /**
     * Called when the content of the font style textField changes.
     */
    private void fontStyleTextFieldChanged() {
        String text = fontStyleTextField.getText().toLowerCase();
        ListModel model = fontStyleList.getModel();
        int size = model.getSize();
        for (int i = 0; i < size; i++) {
            final String name = ((String) model.getElementAt(i));
            String lowerCaseName = name.toLowerCase();
            if (lowerCaseName.equals(text)) {
                String oldName = (String) fontStyleList.getSelectedValue();
                if (!name.equals(oldName)) {
                    // The selection has to be "invoked later" to avoid a concurrent modification
                    fontStyleList.setSelectedValue(name, true);
                }
                break;
            } else if (lowerCaseName.startsWith(text)) {
                fontStyleList.ensureIndexIsVisible(i);
                break;
            }
        }
    }

    /**
     * Called when the selection of the size list changes.
     *
     * @param evt an event.
     */
    private void sizeListValueChanged(ListSelectionEvent evt) {// GEN-FIRST:event_sizeListValueChanged
        if (!evt.getValueIsAdjusting()) {
            JList list = (JList) evt.getSource();
            int index = list.getSelectedIndex();
            if (index >= 0) {
                String value = (String) list.getModel().getElementAt(index);
                int size = Integer.parseInt(value);
                sizeTextField.setText(value);

                Map<TextAttribute, Object> attributes = (Map<TextAttribute, Object>) font.getAttributes();
                attributes.put(TextAttribute.SIZE, size);
                font = new Font(attributes);

                fontChanged();
            }
        }
    }// GEN-LAST:event_sizeListValueChanged

    /**
     * Called when the content of the size textField changes.
     */
    private void sizeTextFieldChanged() {
        String text = sizeTextField.getText().toLowerCase();
        ListModel model = sizeList.getModel();
        int size = model.getSize();
        for (int i = 0; i < size; i++) {
            final String name = ((String) model.getElementAt(i));
            String lowerCaseName = name.toLowerCase();
            if (lowerCaseName.equals(text)) {
                String oldName = (String) sizeList.getSelectedValue();
                if (!name.equals(oldName)) {
                    // The selection has to be "invoked later" to avoid a concurrent modification
                    sizeList.setSelectedValue(name, true);
                }
                break;
            } else if (lowerCaseName.startsWith(text)) {
                sizeList.ensureIndexIsVisible(i);
                break;
            }
        }
    }

    /**
     * Called when the selection of the underline comboBox changes.
     *
     * @param evt an event.
     */
    private void underlineComboBoxItemStateChanged(ItemEvent evt) {// GEN-FIRST:event_underlineComboBoxItemStateChanged
        if (evt.getStateChange() == ItemEvent.SELECTED) {
            JComboBox comboBox = (JComboBox) evt.getSource();
            int index = comboBox.getSelectedIndex();
            if (index >= 0) {
                Map<TextAttribute, Object> attributes = (Map<TextAttribute, Object>) font.getAttributes();
                switch (index) {
                case 0:
                    attributes.put(TextAttribute.UNDERLINE, -1);
                    break;
                case 1:
                    attributes.put(TextAttribute.UNDERLINE,
                            TextAttribute.UNDERLINE_LOW_ONE_PIXEL);
                    break;
                case 2:
                    attributes.put(TextAttribute.UNDERLINE,
                            TextAttribute.UNDERLINE_LOW_TWO_PIXEL);
                    break;
                case 3:
                    attributes.put(TextAttribute.UNDERLINE,
                            TextAttribute.UNDERLINE_LOW_DOTTED);
                    break;
                case 4:
                    attributes.put(TextAttribute.UNDERLINE,
                            TextAttribute.UNDERLINE_LOW_DASHED);
                    break;
                }
                font = new Font(attributes);

                fontChanged();
            }
        }
    }// GEN-LAST:event_underlineComboBoxItemStateChanged

    /**
     * Called when the selection of the strikethrough checkBox changes.
     *
     * @param evt an event.
     */
    private void strikethroughCheckBoxItemStateChanged(ItemEvent evt) {// GEN-FIRST:event_strikethroughCheckBoxItemStateChanged
        Map<TextAttribute, Object> attributes = (Map<TextAttribute, Object>) font.getAttributes();
        boolean b = evt.getStateChange() == ItemEvent.SELECTED;
        attributes.put(TextAttribute.STRIKETHROUGH, (b ? TextAttribute.STRIKETHROUGH_ON
                : -1));
        font = new Font(attributes);

        fontChanged();
    }// GEN-LAST:event_strikethroughCheckBoxItemStateChanged

    /**
     * Called when the selection of the superscript checkBox changes.
     *
     * @param evt an event.
     */
    private void superscriptCheckBoxItemStateChanged(ItemEvent evt) {// GEN-FIRST:event_superscriptCheckBoxItemStateChanged
        Map<TextAttribute, Object> attributes = (Map<TextAttribute, Object>) font.getAttributes();
        if (evt.getStateChange() == ItemEvent.SELECTED) {
            if (evt.getSource() == superscriptCheckBox) {
                subscriptCheckBox.setSelected(false);
            } else {
                superscriptCheckBox.setSelected(false);
            }
        }

        if (superscriptCheckBox.isSelected()) {
            attributes.put(TextAttribute.SUPERSCRIPT, TextAttribute.SUPERSCRIPT_SUPER);
        } else if (subscriptCheckBox.isSelected()) {
            attributes.put(TextAttribute.SUPERSCRIPT, TextAttribute.SUPERSCRIPT_SUB);
        } else {
            attributes.put(TextAttribute.SUPERSCRIPT, 0);
        }
        font = new Font(attributes);

        fontChanged();
    }// GEN-LAST:event_superscriptCheckBoxItemStateChanged

    /**
     * Called when the user click on the color label.
     *
     * @param evt an event.
     */
    private void selectColorButtonActionPerformed(ActionEvent evt) {// GEN-FIRST:event_selectColorButtonActionPerformed
        if (colorChooser == null) {
            colorChooser = new JColorChooser();
            ok = new ColorTracker(colorChooser);
            colorDialog = JColorChooser.createDialog(this, "Pick a color", true,
                    colorChooser, ok, null);
            colorChooser.setColor(foreground);
        }
        colorDialog.setVisible(true);
        Color color = ok.getColor();
        if (color != null) {
            setTextColor(color);
        }
    }// GEN-LAST:event_selectColorButtonActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private JLabel colorLabel;
    private JLabel colorPickLabel;
    private JPanel effectsPanel;
    private JLabel fontLabel;
    private JList fontList;
    private JScrollPane fontScrollPane;
    private JLabel fontStyleLabel;
    private JList fontStyleList;
    private JScrollPane fontStyleScrollPane;
    private JTextField fontStyleTextField;
    private JTextField fontTextField;
    private JLabel previewLabel;
    private JPanel previewPanel;
    private JButton selectColorButton;
    private JLabel sizeLabel;
    private JList sizeList;
    private JScrollPane sizeScrollPane;
    private JTextField sizeTextField;
    private JCheckBox strikethroughCheckBox;
    private JCheckBox subscriptCheckBox;
    private JCheckBox superscriptCheckBox;
    private JComboBox underlineComboBox;
    private JLabel underlineLabel;
    // End of variables declaration//GEN-END:variables

    /**
     * A main method to test the Panel.
     *
     * @param args the program arguments.
     */
    public static void main(final String[] args) {
        try {
            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        } catch (ClassNotFoundException ex) {
            ex.printStackTrace();
        } catch (InstantiationException ex) {
            ex.printStackTrace();
        } catch (IllegalAccessException ex) {
            ex.printStackTrace();
        } catch (UnsupportedLookAndFeelException ex) {
            ex.printStackTrace();
        }

        JFrame frame = new JFrame("FontChooser Test"); //$NON-NLS-1$
        frame.add(new FontChooser());
        frame.setSize(400, 380);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setLocationByPlatform(true);
        frame.setVisible(true);
    }

    /**
     * @author Olivier Sechet
     * @version 1.0 - Apr 9, 2009
     */
    class ColorTracker implements ActionListener, Serializable {
        JColorChooser chooser;
        Color color;

        public ColorTracker(JColorChooser c) {
            chooser = c;
        }

        public void actionPerformed(ActionEvent e) {
            color = chooser.getColor();
        }

        public Color getColor() {
            return color;
        }
    }
}
